1. // 'number' + 3 + 3

var example1 = 'number' + 3 + 3;
console.log(example1); // number33 ; string //

/* У нас есть переменная example1, ей дано значение 'number' + 3 + 3, где: 
'number' – это строка; 
3 - number;
3 – number;
оператор сложения приводит к конкатенации, то есть происходит склеивание строк, 
если хотя бы один операнд является строкой,то второй также будет преобразован в строку
Результат будет: number33 / тип - string */


2. // null + 3

var example2 = null + 3;
console.log(example2); // 3 ; number //

/* У нас есть переменная example2 и её значение = null + 3;
В данном случае null воспринимается программой как число 0
Происхоит сложение цифр 0 и 3
Результат: 3 / тип - number */






3. // 5 && "qwerty"

var example3 = 5 && "qwerty"
console.log(example3); // qwerty ; string //

/*У нас есть переменная example3 и её значение = 5 && "qwerty"
Оператор && ("И") проверяет,чтобы оба значения были правдивыми, возвращает true, если это так, и false в противном случае
В данном случае, 5 - это number и это true
"qwerty" – это строка и тоже true (так как она заполненная, а не пустая)
Поскольку оба значения (5 и "qwerty") являются "правильными",
выражение 5 && "qwerty" возвращает последнее значение - qwerty / тип - строка
*/ 





4. // +'40' + +'2' + "hillel"; //

var example4 = +'40' + +'2' + "hillel";
console.log(example4);              // 42hillel ; string //

/* У нас есть переменная example4 и её значение = +'40' + +'2' + "hillel". В данном случае:
'40' - это строка;
'2' - это строка;
"hillel" – это строка;
Но перед значением '40' и '2' стоит унарный +, который преобразует их в числа
оператор сложения приводит к конкатенации, то есть происходит склеивание строк, 
если хотя бы один операнд является строкой,то второй также будет преобразован в строку Но 40 и 2 уже преобразованы в числа
Получим сумму 40+2=42 + hillel. Тип - строка, так как число + строка образуют строку при конкатенации */





5. // '10' - 5 === 6; //

var example5 = '10'- 5 === 6;
console.log(example5); //false//

/* У нас есть переменная example5 и её значение = '10' - 5 === 6;. В данном случае: '10'- это строка 5 - это число. 6 - тоже число
Математические операции проводятся в первую очередь.
Оператор строгого равенства (===): сравнивает два значения на равенство как по значению, так и по типу данных.
Оператор вычитания всегда преобразовывает операнды в числа, если это возможно.
10-5 = 5
5 === 6?
Ответ: false ; тип - boolean
*/



6. // true + false //

var example6 = true + false;
console.log(example6);   // 1 ; number //

/* Если мы попробуем сложить булеевые значения true и false
То программа воспримет:  
true - как 1  
false – как 0
Результат получим число 1+0=1 */ 




7. // '4px' - 3 //  

var example7 = '4px' - 3;
console.log(example7); // NaN ; number //

/* У нас есть переменная example7 и её значение = '4px' - 3. В данном случае: '4px'- это строка, 3 - это число
Оператор вычитания всегда преобразовывает операнды в числа, если это возможно. Но значение '4px' - не может быть преобразовано в число, так как там есть буквы
Поэтому, 4px превращается в NaN, а любые операции с NaN дают NaN
NaN хоть и расшифровывается как "not a number", но в JavaScript это считается особое число, поэтому его типом счиатется number
*/




8. // '4' - 3

var example8 = '4' - 3;
console.log(example8); // 1 ; number// 

/*У нас есть переменная example8 и её значение = '4' - 3. В данном случае, "4" - это строка, и 3 - число.
Оператор вычитания всегда преобразовывает операнды в числа, если это возможно.
"4" преобразовывается в число 4
4 - 3 = 1
Ответ: 1 ; тип - число */




9. // '6' + 3 ** 0; //

var example9 = '6' + 3 ** 0;
console.log(example9); // 61 ; string // 

/*У нас есть переменная example9 и её значение = '6' + 3 ** 0;. В данном случае происходит Правоассоциативная операяция: 
сначала возводим число 3 в 0 степень, получаем 1 (3 ** 0 = 1)
Оператор сложения приводит к конкатенации, то есть происходит склеивание строк, 
если хотя бы один операнд является строкой,то второй также будет преобразован в строку
6 - это строка. 1 - это число.
При конкатенация происходит сливание 6 и 1 – получаем строку 61 */



10. // 12 / '6' //

var example10 = 12 / '6';
console.log(example10); // 2 ; number //

/* У нас есть переменная example10 и её значение = 12 / '6';. В данном случае, 12 - это число, "6" - это строка. 
Оператор деления работает только с числами и преобразовывает операнды в числа, если это возможно
Происходит деление 12 на 6 - получаем число 2 
*/



11. // '10' + (5 === 6); //

var example11 = '10' + (5 === 6);
console.log(example11); // 10false ; string //

/* Переменная example11 и её значение = '10' + (5 === 6);
Оператор строгого равенства (===): сравнивает два значения на равенство как по значению, так и по типу данных. 
5 не равно по значению, но равно по типу данных. Ответ: false
"10"  - это строка. происходит конкатенация строк 10 и false
Ответ: 10false ; тип - string */



12. // null == '' //

var example12 = null == '';
console.log(example12); // false ; boolean //

/* У нас есть переменная example12 и её значение = null == '';
Оператор == спавнивает два значения на равенство только по значению. 
Сравнение null  с пустой строкой при помощи == всегда возвращает false
Ответ: false ; тип - boolean */



13. // 3 ** (9 / 3); //

var example13 = 3 ** (9 / 3);
console.log(example13); // 27 ; number // 

/*У нас есть переменная example13 и её значение = 3 ** (9 / 3);
Операции в скобках вполняются в первую очередь
Получется сначала 9 делим на 3 и получаем 3 (9/3 = 3)
2-я операция это возведение 3 в третью степень
Ответ:  27 (тип - number) 
*/


14. // !!'false' == !!'true' // 

var example14 = !!'false' == !!'true';
console.log(example14); // true ; boolean // 

/* У нас есть переменная example14 и её значение = !!'false' == !!'true'; 
По логике двойное отрицание (!!) подобно отсутствию отрицания вообще. 
Получаем true равно true? Ответ: Да, равно, значит ответ выведет true
'false' - это заполненная строка , значит - true
!'false': c помощью оператора одного отрицания - выведет false
!! 'false': двойное отрицание снова выведет true
'true' - это заполненная строка , значит ответ выведет true
!'true' : c помощь оператора одного отрицания выведет false
!! 'true': двойное отрицание снова выведет true 
Итак: !! 'true' - это true ; !!'false' - тоже true
Оператор == спавнивает два значения на равенство только по значению
true = true: Ответ: true ; Тип - boolean */



15. // 0 || '0' && 1 //

var example15 = 0 || '0' && 1;
console.log(example15); // result: 1 ; number //

/*У нас есть переменная example15 и её значение = 0 || '0' && 1;
Логическое "И" (&&) вычисляет операнды слева направо, возвращая сразу значение первого попавшего ложного значения; 
если все значения true, возвращается значение последнего операнда
Оператор "И" (&&) имеет более высокий приоритет, чем оператор "ИЛИ" (||), поэтому оператор "И" (&&) выполнится раньше оператора "ИЛИ" (||)
‘0’ true, так как это не пустая строка
1 – тоже true
При операции ('0' && 1) ответ = 1
0 || 1
Для оператора ||  "ИЛИ"  важно, чтобы хоть где-то было true
Ответ будет - 1 */



16. // (+null == false) < 1; // 

var example16 = (+null == false) < 1;
console.log(example16);   // false //

/*У нас есть переменная example16 и её значение = (+null == false) < 1;
Оператор равенства == сравнивае на равенство по значению. 
Операнды разных типов преобразуются оператором == к числу
В данном случае, +null – это null с унарным плюсом, переводится в число 0. 
False – также равен по значению 0. 
Итак: +null == false: 0 = 0 
Ответ: true, а true  = 1. 
Дальше операция больше / меньше:
1 < 1 
Ответ: false, потому что они равны. Тип - boolean */ 




17. // false && true || true //

var example17 =  false && true || true
console.log(example17); // true ; boolean//

/*У нас есть переменная example17 и её значение = false && true || true;
Логическое "И" (&&)  возвращает true, если оба аргумента истинны, а иначе – false; 
если все значения true, возвращается значение последнего операнда
Оператор "И" (&&) имеет более высокий приоритет, чем оператор "ИЛИ" (||), поэтому оператор "И" (&&) выполнится раньше оператора "ИЛИ" (||)
если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false
|| - оператор 'ИЛИ". Для него важно, чтобы хоть где-то было true
1. операция: false && true = false
2. ( false || true ) =  true
Ответ: true. Тип -boolean
*/



18. //false && (false || true); //

var example18 = false && (false || true);
console.log(example18); // ответ: false //


/*У нас есть переменная example18 и её значение = false && (false || true);
Первая операция выполняется в скобках
|| - оператор 'ИЛИ". Для него важно, чтобы хоть где-то было true
( false || true ) = ответ: true
"И" (&&) возвращает true, если оба аргумента истинны, а иначе – false
false && true - ответ будет: false 
*/



19. // (+null == false) < 1 ** 5; //

var example19 = (+null == false) < 1 ** 5;
console.log(example19); // ответ: false // 

/*У нас есть переменная example19 и её значение = (+null == false) < 1 ** 5;
Оператор равенства == сравнивае на равенство по значению. 
Операнды разных типов преобразуются оператором == к числу
В данном случае, +null – это null с унарным плюсом, переводится в число 0. 
False – также равен по значению 0. 
Итак: +null == false: рассчитывается как 0 = 0 
Ответ: true, а true  = 1.
Дальше, рассчитываем 1 в 5-й степени: 1 **5 = 1
Итак, (+null == false) - у нас true и = 1 
1 **5 = 1
1 < 1 
Ответ: false, потому что они равны
*/










































